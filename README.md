# Signaling

## Зміст
- [Завдання 1: Контролер сигналів з побудовою часової лінії](#завдання-1-контролер-сигналів-з-побудовою-часової-лінії)

---

## Завдання 1: Контролер сигналів з побудовою часової лінії

### Опис
Розроблено програму-контролер на C, яка приймає та обробляє сигнали від декількох дочірніх процесів (робітників). Контролер фіксує час отримання кожного сигналу (з точністю до наносекунд), ідентифікатор процесу-відправника та номер сигналу. Після завершення роботи всіх робітників та отримання очікуваної кількості сигналів, контролер сортує всі зареєстровані події за часом і виводить їх у вигляді текстової псевдографічної часової лінії. Ця лінія показує абсолютний час кожної події, час відносно попередньої події, та в "доріжці" якого робітника (за його PID) надійшов відповідний сигнал.

### Ключові технології та механізми:
- Створення дочірніх процесів: `fork()`
- Надсилання сигналів: `kill()`
- Обробка сигналів: `sigaction()` (з прапорцем `SA_SIGINFO` для отримання деталей про сигнал, таких як PID відправника).
- Безпечна передача даних з обробника сигналу в основний цикл: техніка "self-pipe" (використання неблокуючого pipe та системного виклику `select()` для моніторингу).
- Фіксація часу: `clock_gettime(CLOCK_REALTIME, ...)` для отримання точних міток часу.
- Динамічне зберігання подій: використання `realloc()` для масиву структур, що описують події.
- Сортування подій: стандартна функція `qsort()` з кастомною функцією порівняння за часом.
- Очікування завершення дочірніх процесів: `waitpid()` з опцією `WNOHANG` для неблокуючої перевірки та `wait()` для фінального збору.
- Форматування виводу: `snprintf()` для формування рядків та `strsignal()` для отримання назв сигналів.
- Обробка `SIGINT` (Ctrl+C) для коректного завершення роботи контролера.

### Результати
```
КОНТРОЛЕР (PID: 1348): Старт програми.
КОНТРОЛЕР: Створюю 3 робітників...
КОНТРОЛЕР: Всі робітники створені. Очікую на сигнали...
  РОБІТНИК 3 (PID 1351): Стартував, надсилатиму сигнали контролеру (PID 1348).
  РОБІТНИК 2 (PID 1350): Стартував, надсилатиму сигнали контролеру (PID 1348).
  РОБІТНИК 1 (PID 1349): Стартував, надсилатиму сигнали контролеру (PID 1348).
  РОБІТНИК 2 (PID 1350): Надсилаю сигнал User defined signal 1 (30) контролеру.
КОНТРОЛЕР: Зареєстровано сигнал User defined signal 1 (30) від PID 1350.
  РОБІТНИК 3 (PID 1351): Надсилаю сигнал User defined signal 1 (30) контролеру.
КОНТРОЛЕР: Зареєстровано сигнал User defined signal 1 (30) від PID 1351.
  РОБІТНИК 2 (PID 1350): Надсилаю сигнал User defined signal 2 (31) контролеру.
  РОБІТНИК 2 (PID 1350): Всі сигнали надіслано. Завершую роботу.
КОНТРОЛЕР: Зареєстровано сигнал User defined signal 2 (31) від PID 1350.
КОНТРОЛЕР: Робітник PID 1350 завершив роботу зі статусом 2.
  РОБІТНИК 1 (PID 1349): Надсилаю сигнал User defined signal 1 (30) контролеру.
КОНТРОЛЕР: Зареєстровано сигнал User defined signal 1 (30) від PID 1349.
  РОБІТНИК 3 (PID 1351): Надсилаю сигнал User defined signal 2 (31) контролеру.
  РОБІТНИК 3 (PID 1351): Всі сигнали надіслано. Завершую роботу.
КОНТРОЛЕР: Зареєстровано сигнал User defined signal 2 (31) від PID 1351.
  РОБІТНИК 1 (PID 1349): Надсилаю сигнал User defined signal 2 (31) контролеру.
  РОБІТНИК 1 (PID 1349): Всі сигнали надіслано. Завершую роботу.
КОНТРОЛЕР: Зареєстровано сигнал User defined signal 2 (31) від PID 1349.
КОНТРОЛЕР: Робітник PID 1351 завершив роботу зі статусом 3.
КОНТРОЛЕР: Робітник PID 1349 завершив роботу зі статусом 1.
КОНТРОЛЕР: Всі робітники завершились і очікувані сигнали отримано.

КОНТРОЛЕР: Основний цикл завершено. Оброблено 6 подій.

--- Часова Лінія Отриманих Сигналів ---
Абсолютний час        | Відносний час  | Робітник (PID 1349)        |  Робітник (PID 1350)       |  Робітник (PID 1351)       |
--------------------- | -------------- | -------------------------- | -------------------------- | -------------------------- |
1748871601.589428767  | +0.000000000s  |                            | User defined signal 1 (30) |                            |
1748871601.812386376  | +0.222957609s  |                            |                            | User defined signal 1 (30) |
1748871601.873939512  | +0.061553136s  |                            | User defined signal 2 (31) |                            |
1748871602.310388380  | +0.436448868s  | User defined signal 1 (30) |                            |                            |
1748871602.718124929  | +0.407736549s  |                            |                            | User defined signal 2 (31) |
1748871602.865955406  | +0.147830477s  | User defined signal 2 (31) |                            |                            |
------------------------------------------------------------------------------------------------------------------------------
КОНТРОЛЕР: Завершення роботи.
```

### Пояснення
- **Ініціалізація:** Контролер створює pipe (self-pipe) для безпечної комунікації між обробником сигналу та основним циклом. Встановлюються обробники для сигналів `SIGUSR1` та `SIGUSR2`, які будуть надсилатися робітниками, а також для `SIGINT` (Ctrl+C) для можливості коректного завершення роботи контролера. Обробник для `SIGUSR1`/`SIGUSR2` використовує прапорець `SA_SIGINFO` для отримання розширеної інформації про сигнал, зокрема PID процесу-відправника.
- **Створення робітників:** Контролер запускає визначену кількість дочірніх процесів (`NUM_WORKERS`). Кожен робітник, після випадкової затримки, надсилає контролеру певну кількість сигналів (`SIGNALS_PER_WORKER`), чергуючи, наприклад, `SIGUSR1` та `SIGUSR2`.
- **Обробка сигналів:** При отриманні сигналу спрацьовує встановлений обробник. Він записує ключову інформацію про сигнал (номер сигналу та PID відправника) у write-кінець self-pipe. Це є асинхронно-безпечною операцією.
- **Основний цикл контролера:**
    - Використовує системний виклик `select()` для моніторингу read-кінця self-pipe на предмет появи даних. `select()` має таймаут, що дозволяє періодично перевіряти прапорець `terminate_controller_flag` (встановлюється обробником `SIGINT`).
    - Коли `select()` сигналізує про наявність даних, контролер читає інформацію про подію з pipe.
    - Негайно після успішного читання з pipe, контролер фіксує поточний час за допомогою `clock_gettime()` і створює структуру `SignalEvent`, що містить мітку часу, номер сигналу та PID відправника. Ця подія додається до динамічного масиву.
    - У цьому ж циклі контролер неблокуюче перевіряє, чи не завершився якийсь із дочірніх процесів, використовуючи `waitpid(-1, ..., WNOHANG)`.
- **Завершення, сортування та вивід:** Основний цикл триває, доки не будуть зібрані всі робітники та очікувана кількість сигналів, або доки не буде встановлено прапорець `terminate_controller_flag`. Після завершення циклу всі зібрані події `SignalEvent` сортуються за міткою часу за допомогою `qsort()`. Відсортовані події виводяться у вигляді табличної часової лінії, де для кожної події вказується абсолютний час, час відносно попередньої події, а також у спеціальній колонці для відповідного PID робітника позначається отриманий сигнал.

### Висновки
- Програма успішно демонструє реалізацію контролера, здатного асинхронно приймати та реєструвати сигнали від множини процесів.
- Використання техніки "self-pipe" у поєднанні з `select()` є ефективним та безпечним методом для обробки сигналів в UNIX-подібних системах. Цей підхід дозволяє уникнути багатьох проблем, пов'язаних з асинхронною безпекою функцій, які викликаються безпосередньо з обробника сигналу.
- Точна фіксація часу подій та їх подальше сортування дозволяють аналізувати послідовність взаємодій між процесами.
- Псевдографічне представлення часової лінії у текстовому вигляді надає наочний спосіб візуалізації отриманих сигналів та їх джерел у хронологічному порядку.
- Програма також включає базову обробку сигналу `SIGINT` для більш контрольованого завершення роботи.

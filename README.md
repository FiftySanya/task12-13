# Signaling

## Зміст
- [Завдання 1: Контролер сигналів з побудовою часової лінії](#завдання-1-контролер-сигналів-з-побудовою-часової-лінії)
- [Завдання 2: Базова обробка SIGINT](#завдання-2-базова-обробка-sigint)
- [Завдання 3: Обробка кількох сигналів (SIGINT та SIGTERM)](#завдання-3-обробка-кількох-сигналів-sigint-та-sigterm)
- [Завдання 4: Перехоплення та отримання інформації про помилку (SIGSEGV)](#завдання-4-перехоплення-та-отримання-інформації-про-помилку-sigsegv)
- [Завдання 5: Міжпроцесорна комунікація за допомогою сигналів реального часу (sigqueue)](#завдання-5-міжпроцесорна-комунікація-за-допомогою-сигналів-реального-часу-sigqueue)

---

## Завдання 1: Контролер сигналів з побудовою часової лінії

### Опис
Розроблено програму-контролер на C, яка приймає та обробляє сигнали від декількох дочірніх процесів (робітників). Контролер фіксує час отримання кожного сигналу (з точністю до наносекунд), ідентифікатор процесу-відправника та номер сигналу. Після завершення роботи всіх робітників та отримання очікуваної кількості сигналів, контролер сортує всі зареєстровані події за часом і виводить їх у вигляді текстової псевдографічної часової лінії. Ця лінія показує абсолютний час кожної події, час відносно попередньої події, та в контексті якого робітника (за його PID) надійшов відповідний сигнал.

### Ключові технології та механізми:
- Створення дочірніх процесів: `fork()`
- Надсилання сигналів: `kill()`
- Обробка сигналів: `sigaction()` (з прапорцем `SA_SIGINFO` для отримання деталей про сигнал, таких як PID відправника).
- Безпечна передача даних з обробника сигналу в основний цикл: техніка "self-pipe" (використання неблокуючого pipe та системного виклику `select()` для моніторингу).
- Фіксація часу: `clock_gettime(CLOCK_REALTIME, ...)` для отримання точних міток часу.
- Динамічне зберігання подій: використання `realloc()` для масиву структур, що описують події.
- Сортування подій: стандартна функція `qsort()` з кастомною функцією порівняння за часом.
- Очікування завершення дочірніх процесів: `waitpid()` з опцією `WNOHANG` для неблокуючої перевірки та `wait()` для фінального збору.
- Форматування виводу: `snprintf()` для формування рядків та `strsignal()` для отримання назв сигналів.
- Обробка `SIGINT` (Ctrl+C) для коректного завершення роботи контролера.

### Результати
```
КОНТРОЛЕР (PID: 1348): Старт програми.
КОНТРОЛЕР: Створюю 3 робітників...
КОНТРОЛЕР: Всі робітники створені. Очікую на сигнали...
  РОБІТНИК 3 (PID 1351): Стартував, надсилатиму сигнали контролеру (PID 1348).
  РОБІТНИК 2 (PID 1350): Стартував, надсилатиму сигнали контролеру (PID 1348).
  РОБІТНИК 1 (PID 1349): Стартував, надсилатиму сигнали контролеру (PID 1348).
  РОБІТНИК 2 (PID 1350): Надсилаю сигнал User defined signal 1 (30) контролеру.
КОНТРОЛЕР: Зареєстровано сигнал User defined signal 1 (30) від PID 1350.
  РОБІТНИК 3 (PID 1351): Надсилаю сигнал User defined signal 1 (30) контролеру.
КОНТРОЛЕР: Зареєстровано сигнал User defined signal 1 (30) від PID 1351.
  РОБІТНИК 2 (PID 1350): Надсилаю сигнал User defined signal 2 (31) контролеру.
  РОБІТНИК 2 (PID 1350): Всі сигнали надіслано. Завершую роботу.
КОНТРОЛЕР: Зареєстровано сигнал User defined signal 2 (31) від PID 1350.
КОНТРОЛЕР: Робітник PID 1350 завершив роботу зі статусом 2.
  РОБІТНИК 1 (PID 1349): Надсилаю сигнал User defined signal 1 (30) контролеру.
КОНТРОЛЕР: Зареєстровано сигнал User defined signal 1 (30) від PID 1349.
  РОБІТНИК 3 (PID 1351): Надсилаю сигнал User defined signal 2 (31) контролеру.
  РОБІТНИК 3 (PID 1351): Всі сигнали надіслано. Завершую роботу.
КОНТРОЛЕР: Зареєстровано сигнал User defined signal 2 (31) від PID 1351.
  РОБІТНИК 1 (PID 1349): Надсилаю сигнал User defined signal 2 (31) контролеру.
  РОБІТНИК 1 (PID 1349): Всі сигнали надіслано. Завершую роботу.
КОНТРОЛЕР: Зареєстровано сигнал User defined signal 2 (31) від PID 1349.
КОНТРОЛЕР: Робітник PID 1351 завершив роботу зі статусом 3.
КОНТРОЛЕР: Робітник PID 1349 завершив роботу зі статусом 1.
КОНТРОЛЕР: Всі робітники завершились і очікувані сигнали отримано.

КОНТРОЛЕР: Основний цикл завершено. Оброблено 6 подій.

--- Часова Лінія Отриманих Сигналів ---
Абсолютний час        | Відносний час  | Робітник (PID 1349)        |  Робітник (PID 1350)       |  Робітник (PID 1351)       |
--------------------- | -------------- | -------------------------- | -------------------------- | -------------------------- |
1748871601.589428767  | +0.000000000s  |                            | User defined signal 1 (30) |                            |
1748871601.812386376  | +0.222957609s  |                            |                            | User defined signal 1 (30) |
1748871601.873939512  | +0.061553136s  |                            | User defined signal 2 (31) |                            |
1748871602.310388380  | +0.436448868s  | User defined signal 1 (30) |                            |                            |
1748871602.718124929  | +0.407736549s  |                            |                            | User defined signal 2 (31) |
1748871602.865955406  | +0.147830477s  | User defined signal 2 (31) |                            |                            |
------------------------------------------------------------------------------------------------------------------------------
КОНТРОЛЕР: Завершення роботи.
```

### Пояснення
- **Ініціалізація:** Контролер створює pipe (self-pipe) для безпечної комунікації між обробником сигналу та основним циклом. Встановлюються обробники для сигналів `SIGUSR1` та `SIGUSR2`, які будуть надсилатися робітниками, а також для `SIGINT` (Ctrl+C) для можливості коректного завершення роботи контролера. Обробник для `SIGUSR1`/`SIGUSR2` використовує прапорець `SA_SIGINFO` для отримання розширеної інформації про сигнал, зокрема PID процесу-відправника.
- **Створення робітників:** Контролер запускає визначену кількість дочірніх процесів (`NUM_WORKERS`). Кожен робітник, після випадкової затримки, надсилає контролеру певну кількість сигналів (`SIGNALS_PER_WORKER`), чергуючи, наприклад, `SIGUSR1` та `SIGUSR2`.
- **Обробка сигналів:** При отриманні сигналу спрацьовує встановлений обробник. Він записує ключову інформацію про сигнал (номер сигналу та PID відправника) у write-кінець self-pipe. Це є асинхронно-безпечною операцією.
- **Основний цикл контролера:**
    - Використовує системний виклик `select()` для моніторингу кінця self-pipe на предмет появи даних. `select()` має таймаут, що дозволяє періодично перевіряти прапорець `terminate_controller_flag` (встановлюється обробником `SIGINT`).
    - Коли `select()` сигналізує про наявність даних, контролер читає інформацію про подію з pipe.
    - Негайно після успішного читання з pipe, контролер фіксує поточний час за допомогою `clock_gettime()` і створює структуру `SignalEvent`, що містить мітку часу, номер сигналу та PID відправника. Ця подія додається до динамічного масиву.
    - У цьому ж циклі контролер неблокуюче перевіряє, чи не завершився якийсь із дочірніх процесів, використовуючи `waitpid(-1, ..., WNOHANG)`.
- **Завершення, сортування та вивід:** Основний цикл триває, доки не будуть зібрані всі робітники та очікувана кількість сигналів, або доки не буде встановлено прапорець `terminate_controller_flag`. Після завершення циклу всі зібрані події `SignalEvent` сортуються за міткою часу за допомогою `qsort()`. Відсортовані події виводяться у вигляді табличної часової лінії, де для кожної події вказується абсолютний час, час відносно попередньої події, а також у спеціальній колонці для відповідного PID робітника позначається отриманий сигнал.

### Висновки
- Програма успішно демонструє реалізацію контролера, здатного асинхронно приймати та реєструвати сигнали від множини процесів.
- Використання техніки "self-pipe" у поєднанні з `select()` є ефективним та безпечним методом для обробки сигналів в UNIX-подібних системах. Цей підхід дозволяє уникнути багатьох проблем, пов'язаних з асинхронною безпекою функцій, які викликаються з обробника сигналу.
- Програма також включає базову обробку сигналу `SIGINT` для більш контрольованого завершення роботи.

## Завдання 2: Базова обробка SIGINT

### Опис
Програма демонструє найпростіший спосіб перехоплення сигналу `SIGINT` (який зазвичай генерується натисканням Ctrl+C). Замість стандартної дії завершення програми, викликається користувацький обробник.

### Результати
```
^CCaught signal 2
```
(де 2 – це типовий числовий код для `SIGINT`).

### Пояснення
- Функція `signal(SIGINT, handle_sigint)` встановлює `handle_sigint` як обробник для сигналу `SIGINT`.
- Функція `handle_sigint` просто виводить повідомлення про те, що сигнал був перехоплений, вказуючи його номер.
- Основний цикл `while (1)` утримує програму активною, дозволяючи їй отримувати сигнали.

### Висновки
- За допомогою функції `signal()` можна змінити стандартну реакцію програми на певні сигнали.
- Це дозволяє програмі виконувати специфічні дії (наприклад, логування, збереження стану) замість негайного завершення при отриманні сигналу переривання.

## Завдання 3: Обробка кількох сигналів (SIGINT та SIGTERM)

### Опис
Ця програма розширює попередній приклад, демонструючи обробку двох різних сигналів: `SIGINT` (Ctrl+C) та `SIGTERM` (сигнал завершення, що надсилається командою `kill`).

### Результати
```
PID: 1115
^CCaught SIGINT (Ctrl+C)
Caught SIGTERM, exiting...
```

### Пояснення
- Два окремі обробники, `handle_sigint` та `handle_sigterm`, встановлюються для відповідних сигналів за допомогою `signal()`.
- `handle_sigint` лише виводить повідомлення.
- `handle_sigterm` виводить повідомлення та потім коректно завершує програму за допомогою `_exit(0)`.
- Виклик `sleep(1)` в основному циклі зменшує навантаження на процесор, дозволяючи програмі ефективно очікувати на сигнали.

### Висновки
- Одна програма може обробляти декілька різних сигналів, призначаючи для кожного свій обробник або використовуючи один обробник для кількох сигналів.

## Завдання 4: Перехоплення та отримання інформації про помилку (SIGSEGV)

### Опис
Програма демонструє використання сучаснішого механізму `sigaction` для встановлення обробника сигналу, зокрема для `SIGSEGV` (помилка сегментації). Використання прапорця `SA_SIGINFO` дозволяє обробнику отримати детальну інформацію про подію, що спричинила сигнал.

### Результати
При запуску програма намагається записати дані за нульовим вказівником, що спричиняє помилку сегментації (`SIGSEGV`). Обробник сигналу перехоплює цю подію і виводить інформацію:
```
Caught signal 11
Fault address: 0x0
```
(де 11 – типовий числовий код для `SIGSEGV`, а `0x0` – адреса, що спричинила помилку)/

### Пояснення
- Структура `struct sigaction` використовується для налаштування обробника.
- `sa.sa_sigaction = handler;` призначає обробник, який приймає три аргументи (`int sig`, `siginfo_t *info`, `void *ucontext`).
- `sa.sa_flags = SA_SIGINFO;` вказує системі використовувати поле `sa_sigaction` та передавати розширену інформацію про сигнал.
- `sigaction(SIGSEGV, &sa, NULL);` встановлює обробник для `SIGSEGV`.
- У функції `handler`, `info->si_addr` містить адресу пам'яті, доступ до якої спричинив помилку.
- Навмисна помилка `*p = 42;` (де `p` є `NULL`) генерує `SIGSEGV`.

### Висновки
- `sigaction` з `SA_SIGINFO` є потужним інструментом для детального аналізу причин виникнення сигналів, особливо тих, що пов'язані з помилками виконання (як `SIGSEGV`, `SIGFPE`, `SIGILL`, `SIGBUS`).
- Отримання адреси помилки (`si_addr`) може значно допомогти у відлагодженні складних проблем, пов'язаних із пам'яттю.

## Завдання 5: Міжпроцесорна комунікація за допомогою сигналів реального часу (sigqueue)

### Опис
Це завдання демонструє передачу даних між двома процесами за допомогою сигналів реального часу та функції `sigqueue`. Один процес (`publisher.c`) надсилає сигнал разом із цілочисельним значенням іншому процесу (`subscriber.c`), який очікує та обробляє цей сигнал.

### Результати
1.  Спочатку запускається `subscriber`:
    ```
    ./task5_subscriber
    Subscriber PID: 1152
    ```
2.  Потім, в іншому терміналі, запускається `publisher`, передаючи йому PID підписника як аргумент командного рядка:
    ```
    ./task5_publisher 1152
    ```
3.  Після цього `subscriber` отримає сигнал і виведе:
    ```
    Received 65 from PID 1159 with value 99
    ```

### Пояснення
- **`subscriber.c` (Підписник):**
  - Використовує `sigaction` з `SA_SIGINFO` для встановлення обробника на сигнал `SIGRTMIN`.
  - Обробник `handler` виводить номер отриманого сигналу, PID процесу-відправника (`info->si_pid`) та цілочисельне значення, передане разом із сигналом (`info->si_value.sival_int`).
  - Входить у нескінченний цикл `pause()`, очікуючи на сигнали.
- **`publisher.c` (Видавець):**
  - Приймає PID процесу-підписника як аргумент командного рядка (`argv[1]`).
  - Готує дані для передачі: `union sigval val; val.sival_int = 99;`.
  - Використовує `sigqueue(pid, SIGRTMIN, val);` для надсилання сигналу `SIGRTMIN` разом зі значенням `val` вказаному процесу `pid`.

### Висновки
- Сигнали реального часу (разом із `sigqueue` та `SA_SIGINFO`) дозволяють не тільки сповіщати інший процес про подію, але й передавати невеликий обсяг даних (ціле число або вказівник).
- Це розширює можливості сигналів як механізму міжпроцесорної комунікації (IPC), хоча для передачі великих обсягів даних існують більш придатні механізми (pipes, shared memory, message queues).
